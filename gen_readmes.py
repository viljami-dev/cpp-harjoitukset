#!/usr/bin/env python3
# -*- coding: utf-8 -*-
<<<<<<< HEAD
"""
gen_readmes.py
--------------
Creates English README.md files for each task folder and a root README with an
auto-generated folder index. Designed for a C++ exercise portfolio.

Default behavior:
- Scans immediate subfolders under --root (default: current directory)
- Creates README.md in each folder that contains at least one .cpp (or CMakeLists.txt)
- Does NOT overwrite existing README.md unless --force is provided
- Creates/updates root README.md:
  * If README.md doesn't exist -> create a concise root README
  * If README.md exists -> (idempotently) updates index between markers:
      <!-- AUTO_INDEX_START --> ... <!-- AUTO_INDEX_END -->

Usage examples:
  python gen_readmes.py
  python gen_readmes.py --root . --force
  python gen_readmes.py --dry-run
"""
=======
>>>>>>> 905f09d (Add autogenerated READMEs)

from __future__ import annotations
import argparse
from pathlib import Path
import re
<<<<<<< HEAD
from typing import List, Tuple
=======
>>>>>>> 905f09d (Add autogenerated READMEs)

INDEX_START = "<!-- AUTO_INDEX_START -->"
INDEX_END   = "<!-- AUTO_INDEX_END -->"

IGNORED_DIRS = {
<<<<<<< HEAD
    ".git", ".idea", ".vscode", "__pycache__", "build", "cmake-build-debug",
    "cmake-build-release", "CMakeFiles", ".DS_Store"
}

def looks_like_task_dir(d: Path) -> bool:
    """A directory qualifies if it contains at least one .cpp OR a CMakeLists.txt."""
=======
    ".git", ".idea", ".vscode", "__pycache__", "build",
    "cmake-build-debug", "cmake-build-release", "CMakeFiles", ".DS_Store"
}

TASK_TEMPLATE = (
    "# Task {FOLDER} (Folder: {FOLDER})\n\n"
    "**Goal:** Briefly describe what this program does in 1–2 sentences.\n\n"
    "## Build & Run (CMake or g++)\n"
    "**CMake** (if `CMakeLists.txt` exists):\n\n"
    "    cmake -S . -B build\n"
    "    cmake --build build --config Release\n"
    "    ./build/<executable_name>        # Linux/macOS\n"
    "    .\\build\\Release\\<executable>.exe # Windows (MSVC)\n\n"
    "**g++** (single-file or small set):\n\n"
    "    g++ -std=c++17 -O2 main.cpp -o app\n"
    "    ./app            # Linux/macOS\n"
    "    .\\app.exe        # Windows\n\n"
    "## What I learned\n"
    "- Add 1–2 short bullets (e.g., input validation, STL vectors/algorithms)\n"
)

ROOT_TEMPLATE = (
    "# C++ Exercises (Course Portfolio)\n\n"
    "This repository contains a collection of C++ programming exercises completed during my studies.\n"
    "Each task resides in its own folder. Build either with **CMake** (when `CMakeLists.txt` exists) or directly using **g++**.\n\n"
    "> Editor/build artifacts (e.g., `.idea/`, `cmake-build-*`) are intentionally excluded from version control.\n\n"
    "## Folder Index\n"
    "{INDEX_START}\n"
    "<!-- The list below is auto-generated by gen_readmes.py. Do not edit manually. -->\n"
    "{INDEX_END}\n\n"
    "## How to Build & Run\n\n"
    "**CMake:**\n\n"
    "    cmake -S . -B build\n"
    "    cmake --build build --config Release\n"
    "    ./build/<executable_name>        # Linux/macOS\n"
    "    .\\build\\Release\\<executable>.exe # Windows (MSVC)\n\n"
    "**g++ (single file):**\n\n"
    "    g++ -std=c++17 -O2 main.cpp -o app\n"
    "    ./app\n\n"
    "## Topics (high level)\n"
    "- Console I/O, conditionals, loops\n"
    "- Functions and modularisation\n"
    "- Classes & basic OOP\n"
    "- STL containers/algorithms\n"
    "- File I/O\n"
    "- Pointers & dynamic memory (where applicable)\n"
)

def looks_like_task_dir(d: Path) -> bool:
>>>>>>> 905f09d (Add autogenerated READMEs)
    if not d.is_dir():
        return False
    name = d.name
    if name in IGNORED_DIRS or name.startswith("."):
        return False
<<<<<<< HEAD
    # Do not descend into common build/meta folders by prefix
    for bad_prefix in ("cmake-build-",):
        if name.startswith(bad_prefix):
            return False
=======
    if name.startswith("cmake-build-"):
        return False
>>>>>>> 905f09d (Add autogenerated READMEs)
    has_cpp = any(f.suffix.lower() == ".cpp" for f in d.glob("*.cpp"))
    has_cmake = (d / "CMakeLists.txt").exists()
    return has_cpp or has_cmake

<<<<<<< HEAD
def discover_task_dirs(root: Path) -> List[Path]:
    return sorted([d for d in root.iterdir() if looks_like_task_dir(d)], key=lambda p: p.name.lower())

def task_readme_content(folder_name: str) -> str:
    """Unified, compact README content in English."""
    return f"""# Task {folder_name} (Folder: {folder_name})

**Goal:** Briefly describe what this program does in 1–2 sentences.

## Build & Run (CMake or g++)
**CMake** (if `CMakeLists.txt` exists):
```bash
cmake -S . -B build
cmake --build build --config Release
./build/<executable_name>        # Linux/macOS
.\build\\Release\\<executable>.exe # Windows (MSVC)
=======
def discover_task_dirs(root: Path):
    return sorted([d for d in root.iterdir() if looks_like_task_dir(d)], key=lambda p: p.name.lower())

def write_file(path: Path, content: str):
    path.write_text(content, encoding="utf-8", newline="\n")

def ensure_task_readme(task_dir: Path, force: bool, dry_run: bool):
    readme = task_dir / "README.md"
    if readme.exists() and not force:
        print(f"SKIP  {task_dir.name:10s} README.md exists")
        return
    content = TASK_TEMPLATE.replace("{FOLDER}", task_dir.name)
    if dry_run:
        print(f"DRY   {task_dir.name:10s} would write README.md")
    else:
        write_file(readme, content)
        print(f"WRITE {task_dir.name:10s} README.md")

def render_index(tasks):
    lines = []
    for d in tasks:
        hint = "CMake" if (d / "CMakeLists.txt").exists() else "g++"
        lines.append(f"- {d.name}/ — ({hint})")
    if not lines:
        lines = ["- (no task folders detected)"]
    return "\n".join(lines)

def upsert_root_readme(root: Path, tasks, force: bool, dry_run: bool):
    readme = root / "README.md"
    if not readme.exists():
        base = ROOT_TEMPLATE.replace("{INDEX_START}", INDEX_START).replace("{INDEX_END}", INDEX_END)
        if dry_run:
            print("DRY   root     would create README.md")
        else:
            write_file(readme, base)
            print("WRITE root     README.md created")

    text = readme.read_text(encoding="utf-8")
    index_md = render_index(tasks)
    index_block = f"{INDEX_START}\n{index_md}\n{INDEX_END}"

    if INDEX_START in text and INDEX_END in text:
        new_text = re.sub(
            re.escape(INDEX_START) + r".*?" + re.escape(INDEX_END),
            index_block,
            text,
            flags=re.DOTALL,
        )
    else:
        new_text = text.strip() + f"\n\n## Folder Index\n{index_block}\n"

    if new_text == text and not force:
        print("SKIP  root     README.md index up-to-date")
        return

    if dry_run:
        print("DRY   root     would update README.md index")
    else:
        write_file(readme, new_text)
        print("WRITE root     README.md index updated")

def main():
    ap = argparse.ArgumentParser(description="Generate README.md files for C++ task folders.")
    ap.add_argument("--root", type=str, default=".", help="Root folder (default: current directory)")
    ap.add_argument("--force", action="store_true", help="Overwrite existing README.md files")
    ap.add_argument("--dry-run", action="store_true", help="Show what would change without writing files")
    args = ap.parse_args()

    root = Path(args.root).resolve()
    if not root.exists():
        print(f"Root path not found: {root}")
        return

    tasks = discover_task_dirs(root)
    for d in tasks:
        ensure_task_readme(d, force=args.force, dry_run=args.dry_run)

    upsert_root_readme(root, tasks, force=args.force, dry_run=args.dry_run)

if __name__ == "__main__":
    main()
>>>>>>> 905f09d (Add autogenerated READMEs)
